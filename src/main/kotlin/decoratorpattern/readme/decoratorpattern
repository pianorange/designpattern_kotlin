
Decorator 패턴
-

>스펀지 케이크 + 딸기크림, 초콜릿크림, 치즈크림

케익에 장식을 더해나가는 것처럼 중심이 되는 오브젝트에 장식이 되는 기능을 하나씩 추가해 나가는 패턴<br>

예제 프로그램은 문자열 주변에 장식을 만들어 표시 

**Component**<br> 
기능 추가시 핵심이 되는 클래스. 스펀지 케이크 인터페이스만을 결정한다. (Displayclass)

**ConcreteComponent** <br>
Component 역할의 인스턴스를 구현하고 있는 구체적인 스펀지 케이크.

**Decorator**<br>
Component 와 동일한 인터페이스를 가지며 Decorator역할이 장식할 대상이 되는 Component역할도 가지고 있다.<br>
이 역할은 자신이 장식하고 있는 대상을 알고 있다. 

**ConcreteDecorator**<br> 
구체적인 Decorator의 역할 예제에서는 SideBorder,FullBorder

![](File-Decorator_UML_class_diagram.png)


  > Decoretor의 특징
  
        OCP(Open-Closed Principle) 
        클래스는 확장에 대해서는 열려있어야 하지만(Open), 코드 변경에 대해서는 닫혀 있어야(Closed) 한다는 의미 입니다. 
        즉, 기존 코드는 건드리지 않은 채로 확장을 통해서 새로운 기능을 추가할 수 있도록 하는 것입니다. 이것이 가능해진다면
        우리는 기능을 유연하게 추가할 수 있으면서도 코드의 안정성 또한 유지할 수 있을 것입니다.

- 투과적인 인터페이스 API<br>
Decorator 패턴에서는 장식과 내용물을 동일시하며, 내용물과 장식 모두 동일한 인터페이스를 가진다.<br>
장식을 사용해서 아무리 내용물을 감싸도 인터페이스는 감춰지는 일 없이 다른 클래스에서 볼 수 있다.<br>
->인터페이스가 투과적 이라고 표현.

- 내용물을 바꾸지 않고 기능을 추가할 수 있다.<br> 
Decorator 패턴에서는 장식과 내용물이 공통의 api를 갖고, 내용물의 기능을 변경하지 않고 장식을 통해<br>
기능을 추가할 수 있다.<br>
이때 '장식'에 대한 요구(메소드의 호출)는 위임을 통해 내용물에 떠넘겨진다. <br>
ex)SideBorder의 getColumns메소드는 display.getColumns()호출

- 동적인 기능을 추가할 수 있다.<br>
 Decorator 패턴에서 이용되는 위임은 클래스 사이를 느슨하게 결합. 
 따라서 framework 소스 변경하지 않고 오브젝트의 관계를 변경한 새로운 오브젝트 만들 수 있다.
 
- 단순한 장식이라도 다양한 기능을 추가할 수 있다<br>
  Decorator 패턴을 사용하면 다양한 기능을 추가할 수 있습니다. 구체적인 장식을 많이 준비해두면 그것들을<br>
  자유롭게 조합해서 새로운 오브젝트를 만들 수 있기 때문입니다. 각각의 장식은 단순해도 상관없다.<br>
  이것은 바닐라,초콜릿,딸기,키위 등의 장식을 자유롭게 선택할 수 있는 아이스크림과 같습니다.<br>                                                                   

- java.io 패키지와 Decorator 패턴<br>
java.io 입출력은 데코레이션 패턴이 사용되어있다.<br>
자바 I/O를 보면 데코레이터의 단점도 발견 할 수 있다.<br>
데코레이터 패턴을 이용해서 디자인을 하다 보면 유사한 성질의 작은 클래스들이 너무 많아져 구조가 난잡해질 수 있다.<br>

![](phani-kumar-decorator-pattern-15-728.jpg)

